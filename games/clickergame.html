<!DOCTYPE html>
<html lang="nl">
<head>
    <title>Clicker Game</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Clicker, Game, Nieuw">
    <meta name="description" content="Game van AEMIG">
    <meta name="author" content="AEM">

    <link rel="stylesheet" href="aemig_games_styles.css">
    <style>
        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
        details, summary {
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas" width="1000" height="600"></canvas>

    <noscript>You dont have Javascript enabled. Make sure to turn it on to play this game.</noscript>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const PPCText = document.getElementById("PPCText");
        const PPSText = document.getElementById("PPSText");

        // Add legenda properties
        const legenda = {
            isOpen: false,
            x: 10,
            y: canvas.height - 250,
            width: 250,
            button: {
                x: 10,
                y: canvas.height - 30,
                width: 100,
                height: 30,
                text: "Legenda",
                isHovered: false
            },
            sections: [
                {
                    title: "PPC",
                    content: "PPC stands for Points Per Click, and defines how many points you get when clicking the button.",
                    isOpen: false
                },
                {
                    title: "PPS",
                    content: "PPS stands for Points Per Second, and defines how many points you get per second.",
                    isOpen: false
                }
            ]
        };

        let mouseX = 0;
        let mouseY = 0;
        let scrollY = 0; // Add scroll position tracking
        onmousemove = function(e){mouseX = e.clientX; mouseY = e.clientY}

        // Button properties
        const clickButton = {
            radius: 150, // Radius of the button
            x: canvas.width / 4, // Center the button horizontally
            y: canvas.height / 2, // Center the button vertically
            color: 'crimson', // Button color
            textColor: '#FFFFFF', // Text color
            text: 'Click Me', // Button text
            isHovered: false,
            shadowColor: 'rgba(0, 0, 0, 0.3)',
            shadowBlur: 20,
            shadowOffset: 10
        };

        let score = 0;
        let pointsPerClick = 1;
        let pointsPerSecond = 0;
        let lastSecond = Date.now();
        let totalClicked = 0;
        let hasReached1000Clicked = false;
        let chance10targets = 0.1;
        let isMinigameActive = false;
        let isMinigamePaused = false;
        let minigameTarget = {
            x: 0,
            y: 0,
            radius: 30,
            color: 'gold',
            points: 0
        };

        let upgrades = [];

        // Add navigation bar properties
        const navBar = {
            height: 40,
            width: 200,
            x: 795,
            y: 0,
            sections: [
                { name: "All", type: "all" },
                { name: "PPC", type: "ppc" },
                { name: "PPS", type: "pps" }
            ],
            activeSection: "all"
        };

        const pauseButton = {
            x: 10,
            y: 10,
            width: 40,
            height: 40,
            color: 'rgba(255, 255, 255, 0.2)',
            hoverColor: 'rgba(255, 255, 255, 0.3)',
            isHovered: false
        };

        let minigameTargets = []; // Array to store multiple targets
        let hasSpawnedMultiple = false; // Track if we've spawned multiple targets

        class Upgrade {
            constructor({
                name = "None",
                type = "None",
                cost = 10,
                position = { x: 0, y: 0},
                bought = false,
                color = "aquamarine",
                textColor = "black",
                width = 200,
                height = 50,
                effect = () => {} // Add an empty function for default effect
            }) {
                this.name = name;
                this.type = type;
                this.cost = cost;
                this.position = position;
                this.bought = bought;
                this.color = color;
                this.textColor = textColor;
                this.width = width;
                this.height = height;
                this.effect = effect;
                this.isHovered = false;
            }

            draw() {
                // Draw button background with rounded corners
                ctx.beginPath();
                ctx.roundRect(this.position.x, this.position.y, this.width, this.height, 10);
                ctx.fillStyle = this.isHovered ? this.adjustColor(this.color, -20) : this.color;
                ctx.fill();
                ctx.strokeStyle = this.adjustColor(this.color, -40);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();

                // Draw text with better formatting
                ctx.fillStyle = this.textColor;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Split text into two lines
                const centerX = this.position.x + this.width / 2;
                const centerY = this.position.y + this.height / 2;
                
                // Draw name
                ctx.fillText(this.name, centerX, centerY - 8);
                
                // Draw cost with smaller font
                ctx.font = '14px Arial';
                ctx.fillText(`Cost: ${this.cost}`, centerX, centerY + 8);
            }

            // Helper function to adjust color brightness
            adjustColor(color, amount) {
                // Create a temporary canvas to convert color name to hex
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.fillStyle = color;
                const hex = tempCtx.fillStyle.replace('#', '');
                
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
        }

        function initUpgrades() {
            let yPos = 5;
            
            // Create PPC upgrades
            for (let i = 0; i < 20; i++) {
                const upg = new Upgrade({
                    position: {
                        x: 795,
                        y: yPos
                    },
                    name: "+1 PPC",
                    type: "PPC",
                    cost: (10 + (i * 10)),
                    effect: () => {
                        pointsPerClick += 1;
                    }
                });
                yPos += (upg.height + 10);
                upgrades.push(upg);
            }

            // Create PPC 1.5x upgrades
            for (let i = 0; i < 20; i++) {
                const upg = new Upgrade({
                    position: {
                        x: 795,
                        y: yPos
                    },
                    name: "1.5x PPC",
                    type: "PPC",
                    cost: (500 + (i * 500)),
                    effect: () => {
                        pointsPerClick *= 1.5;
                    }
                });
                yPos += (upg.height + 10);
                upgrades.push(upg);
            }
            
            // Create PPS upgrades
            for (let i = 0; i < 20; i++) {
                const upg = new Upgrade({
                    position: {
                        x: 795,
                        y: yPos
                    },
                    name: "+1 PPS",
                    type: "PPS",
                    cost: (10 + (i * 20)),
                    effect: () => {
                        pointsPerSecond += 1;
                    }
                });
                yPos += (upg.height + 10);
                upgrades.push(upg);
            }

            // Create PPS 1.5x upgrades
            for (let i = 0; i < 20; i++) {
                const upg = new Upgrade({
                    position: {
                        x: 795,
                        y: yPos
                    },
                    name: "1.5x PPS",
                    type: "PPS",
                    cost: (1000 + (i * 1000)),
                    effect: () => {
                        pointsPerSecond *= 1.5;
                    }
                });
                yPos += (upg.height + 10);
                upgrades.push(upg);
            }
            
            // Log the created upgrades
            //console.log("Created upgrades:");
            upgrades.forEach((upg, index) => {
                //console.log(`${index}: ${upg.name} at y=${upg.position.y}`);
            });
        }
        initUpgrades()

        function startMinigame() {
            isMinigameActive = true;
            minigameTargets = []; // Clear any existing targets
            hasSpawnedMultiple = false;
            moveMinigameTarget();
        }

        function moveMinigameTarget() {
            // Check for 1 in 100 chance to spawn multiple targets
            if (!hasSpawnedMultiple && Math.random() < chance10targets) {
                hasSpawnedMultiple = true;
                // Spawn 10 targets
                for (let i = 0; i < 10; i++) {
                    const target = {
                        x: Math.random() * (canvas.width - minigameTarget.radius * 2) + minigameTarget.radius,
                        y: Math.random() * (canvas.height - minigameTarget.radius * 2) + minigameTarget.radius,
                        radius: 30,
                        color: 'gold',
                        points: 0
                    };
                    minigameTargets.push(target);
                }
            } else {
                // Single target behavior
                if (minigameTargets.length === 0) {
                    const target = {
                        x: Math.random() * (canvas.width - minigameTarget.radius * 2) + minigameTarget.radius,
                        y: Math.random() * (canvas.height - minigameTarget.radius * 2) + minigameTarget.radius,
                        radius: 30,
                        color: 'gold',
                        points: 0
                    };
                    minigameTargets.push(target);
                }
            }
        }

        function drawMinigame() {
            if (!isMinigameActive) return;

            // Draw pause button
            ctx.beginPath();
            ctx.fillStyle = pauseButton.isHovered ? pauseButton.hoverColor : pauseButton.color;
            ctx.fillRect(pauseButton.x, pauseButton.y, pauseButton.width, pauseButton.height);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(pauseButton.x, pauseButton.y, pauseButton.width, pauseButton.height);
            
            // Draw pause icon
            ctx.fillStyle = 'white';
            if (isMinigamePaused) {
                // Play icon (triangle)
                ctx.beginPath();
                ctx.moveTo(pauseButton.x + 15, pauseButton.y + 10);
                ctx.lineTo(pauseButton.x + 15, pauseButton.y + 30);
                ctx.lineTo(pauseButton.x + 30, pauseButton.y + 20);
                ctx.fill();
            } else {
                // Pause icon (two lines)
                ctx.fillRect(pauseButton.x + 12, pauseButton.y + 10, 5, 20);
                ctx.fillRect(pauseButton.x + 23, pauseButton.y + 10, 5, 20);
            }
            ctx.closePath();

            // Only draw targets if not paused
            if (!isMinigamePaused) {
                // Draw all targets
                minigameTargets.forEach(target => {
                    ctx.beginPath();
                    ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2);
                    ctx.fillStyle = target.color;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.closePath();
                });
            } else {
                // Draw "PAUSED" text when paused
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('MINIGAME PAUSED', pauseButton.x + pauseButton.width + 10, pauseButton.y + pauseButton.height/2);
            }
        }

        function checkMinigameClick(mouseX, mouseY) {
            if (!isMinigameActive) return false;

            // Check pause button click
            if (mouseX >= pauseButton.x && mouseX <= pauseButton.x + pauseButton.width &&
                mouseY >= pauseButton.y && mouseY <= pauseButton.y + pauseButton.height) {
                isMinigamePaused = !isMinigamePaused;
                //console.log("Minigame paused:", isMinigamePaused); // Debug log
                return true;
            }

            // Don't check target clicks if paused
            if (isMinigamePaused) return false;

            // Check clicks on all targets
            for (let i = 0; i < minigameTargets.length; i++) {
                const target = minigameTargets[i];
                const distance = Math.sqrt(
                    Math.pow(mouseX - target.x, 2) + 
                    Math.pow(mouseY - target.y, 2)
                );

                if (distance <= target.radius) {
                    const pointsEarned = Math.floor(pointsPerClick * 1.2);
                    target.points += pointsEarned;
                    score += pointsEarned;
                    
                    // Remove the clicked target
                    minigameTargets.splice(i, 1);
                    
                    // If this was the last target, spawn a new one
                    if (minigameTargets.length === 0) {
                        moveMinigameTarget();
                    }
                    
                    return true;
                }
            }
            return false;
        }

        function addPoints() {
            score += pointsPerClick;
            totalClicked++;
            
            // Check for 100 clicks achievement
            if (totalClicked >= 1000 && !hasReached1000Clicked) {
                hasReached1000Clicked = true;
                startMinigame();
            }
        }

        function addPPS() {
        // Add points per second
        const currentTime = Date.now();
            if (currentTime - lastSecond >= 1000) { // Check if 1 second has passed
                score += pointsPerSecond;
                lastSecond = currentTime;
            }
        }

        function cheatPoints(amount) {
            score += amount;
            // Increment totalClicked based on the points added (assuming each click gives 1 point)
            totalClicked += amount;
            
            // Check for 1000 clicks achievement
            if (totalClicked >= 1000 && !hasReached1000Clicked) {
                hasReached1000Clicked = true;
                startMinigame();
            }
        }

        function collision({ obj1, obj2 }) {
            return (
                obj1.position.x + obj1.width >= obj2.position.x && // obj1 right collides with obj2 left
                obj2.position.x + obj2.width >= obj1.position.x && // obj2 right collides with obj1 left
                obj1.position.y + obj1.height >= obj2.position.y && // obj1 bottom collides with obj2 top
                obj2.position.y + obj2.height >= obj1.position.y // obj1 top collides with obj2 bottom
            )
        }

        function mouseCollision(mouseX, mouseY, upgrade) {
            return (
                mouseX >= upgrade.position.x &&
                mouseX <= upgrade.position.x + upgrade.width &&
                mouseY >= upgrade.position.y &&
                mouseY <= upgrade.position.y + upgrade.height
            );
        }

        function drawButton() {
            // Draw shadow
            ctx.beginPath();
            ctx.arc(clickButton.x + clickButton.shadowOffset, clickButton.y + clickButton.shadowOffset, clickButton.radius, 0, Math.PI*2, false);
            ctx.fillStyle = clickButton.shadowColor;
            ctx.filter = `blur(${clickButton.shadowBlur}px)`;
            ctx.fill();
            ctx.filter = 'none';
            ctx.closePath();

            // Draw button background
            ctx.beginPath();
            ctx.arc(clickButton.x, clickButton.y, clickButton.radius, 0, Math.PI*2, false);
            ctx.fillStyle = clickButton.isHovered ? adjustColor(clickButton.color, -20) : clickButton.color;
            ctx.fill();
            
            // Draw button border
            ctx.strokeStyle = adjustColor(clickButton.color, -40);
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.closePath();

            // Draw button text
            ctx.fillStyle = clickButton.textColor;
            
            // Draw score
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(score.toString(), clickButton.x, clickButton.y);
            //ctx.fillText(score.toString(), clickButton.x, clickButton.y - 20);
            
            // Draw "Click Me" text
            //ctx.font = '24px Arial';
            //ctx.fillText('Click Me', clickButton.x, clickButton.y + 30);
        }

        // Helper function to adjust color brightness (moved outside of Upgrade class)
        function adjustColor(color, amount) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = color;
            const hex = tempCtx.fillStyle.replace('#', '');
            
            const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
            const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
            const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function drawNavBar() {
            const sectionWidth = navBar.width / navBar.sections.length;
            
            navBar.sections.forEach((section, index) => {
                const x = navBar.x + (index * sectionWidth);
                
                // Draw section background
                ctx.beginPath();
                ctx.fillStyle = section.type === navBar.activeSection ? adjustColor("aquamarine", -20) : "aquamarine";
                ctx.fillRect(x, navBar.y, sectionWidth, navBar.height);
                ctx.strokeStyle = adjustColor("aquamarine", -40);
                ctx.lineWidth = 2;
                ctx.strokeRect(x, navBar.y, sectionWidth, navBar.height);
                ctx.closePath();
                
                // Draw section text
                ctx.fillStyle = "black";
                ctx.font = "bold 16px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(section.name, x + sectionWidth/2, navBar.y + navBar.height/2);
            });
        }

        function drawUpgrades() {
            // Draw navigation bar
            drawNavBar();
            
            // Adjust y position for upgrades to account for nav bar
            const upgradeStartY = navBar.height + 5;
            let currentY = upgradeStartY;
            
            for (let upg of upgrades) {
                if (!upg.bought) {
                    // Filter upgrades based on active section
                    const shouldShow = navBar.activeSection === "all" || 
                                     (navBar.activeSection === "ppc" && upg.type === "PPC") ||
                                     (navBar.activeSection === "pps" && upg.type === "PPS");
                    
                    if (shouldShow) {
                        // Only draw upgrades that are within the visible area (below nav bar)
                        if (currentY - scrollY >= navBar.height && currentY - scrollY <= canvas.height) {
                            // Store the current position for drawing
                            const drawPosition = {
                                x: upg.position.x,
                                y: currentY - scrollY
                            };
                            
                            // Update hover state using the draw position
                            const canvasRect = canvas.getBoundingClientRect();
                            const adjustedMouseX = mouseX - canvasRect.left;
                            const adjustedMouseY = mouseY - canvasRect.top;
                            upg.isHovered = adjustedMouseX >= drawPosition.x && 
                                          adjustedMouseX <= drawPosition.x + upg.width &&
                                          adjustedMouseY >= drawPosition.y && 
                                          adjustedMouseY <= drawPosition.y + upg.height;
                            
                            // Draw the upgrade button with adjusted position
                            const originalPosition = { ...upg.position };
                            upg.position = drawPosition;
                            upg.draw();
                            upg.position = originalPosition;
                        }
                        
                        // Move to next position
                        currentY += upg.height + 10;
                    }
                }
            }
        }
        
        function addEventListeners() {
            canvas.addEventListener("mouseup", checkClickRadius, false);
            canvas.addEventListener("touchend", checkClickRadius, false);
            canvas.addEventListener("wheel", handleScroll, { passive: true });
        }

        function getMaxScroll() {
            const visibleUpgrades = upgrades.filter(upg => {
                if (upg.bought) return false;
                return navBar.activeSection === "all" || 
                       (navBar.activeSection === "ppc" && upg.type === "PPC") ||
                       (navBar.activeSection === "pps" && upg.type === "PPS");
            });
            const availableHeight = canvas.height - navBar.height - 5; // Account for nav bar and padding
            return Math.max(0, visibleUpgrades.length * (upgrades[0].height + 10) - availableHeight);
        }

        function handleScroll(e) {
            e.preventDefault();
            const scrollAmount = e.deltaY;
            const maxScroll = getMaxScroll();
            
            scrollY = Math.max(0, Math.min(maxScroll, scrollY + scrollAmount));
        }

        function checkNavBarClick(mouseX, mouseY) {
            const sectionWidth = navBar.width / navBar.sections.length;
            
            navBar.sections.forEach((section, index) => {
                const x = navBar.x + (index * sectionWidth);
                if (mouseX >= x && mouseX <= x + sectionWidth &&
                    mouseY >= navBar.y && mouseY <= navBar.y + navBar.height) {
                    navBar.activeSection = section.type;
                    scrollY = 0; // Reset scroll position when changing sections
                }
            });
        }

        function drawLegenda() {
            // Draw legenda button
            ctx.beginPath();
            ctx.fillStyle = legenda.button.isHovered ? adjustColor("aquamarine", -20) : "aquamarine";
            ctx.fillRect(legenda.button.x, legenda.button.y, legenda.button.width, legenda.button.height);
            ctx.strokeStyle = adjustColor("aquamarine", -40);
            ctx.lineWidth = 2;
            ctx.strokeRect(legenda.button.x, legenda.button.y, legenda.button.width, legenda.button.height);
            
            // Draw button text
            ctx.fillStyle = "black";
            ctx.font = "bold 16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(legenda.button.text, legenda.button.x + legenda.button.width/2, legenda.button.y + legenda.button.height/2);
            ctx.closePath();

            if (legenda.isOpen) {
                // Draw legenda background
                ctx.beginPath();
                ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                ctx.fillRect(legenda.x, legenda.y, legenda.width, 200);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                ctx.strokeRect(legenda.x, legenda.y, legenda.width, 200);
                ctx.closePath();

                let currentY = legenda.y + 180; // Start from bottom
                
                // Draw each section in reverse order
                for (let i = legenda.sections.length - 1; i >= 0; i--) {
                    const section = legenda.sections[i];
                    
                    // Draw section title
                    ctx.fillStyle = "white";
                    ctx.font = "bold 16px Arial";
                    ctx.textAlign = "left";
                    ctx.fillText(section.title, legenda.x + 10, currentY);
                    
                    // Draw section content if open
                    if (section.isOpen) {
                        ctx.font = "14px Arial";
                        const lines = wrapText(section.content, legenda.width - 20);
                        for (let j = lines.length - 1; j >= 0; j--) {
                            currentY -= 20;
                            ctx.fillText(lines[j], legenda.x + 10, currentY);
                        }
                    }
                    
                    currentY -= 30;
                }
            }
        }

        function wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + ' ' + word).width;
                if (width < maxWidth) {
                    currentLine += ' ' + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        function checkLegendaClick(mouseX, mouseY) {
            // Check legenda button click
            if (mouseX >= legenda.button.x && mouseX <= legenda.button.x + legenda.button.width &&
                mouseY >= legenda.button.y && mouseY <= legenda.button.y + legenda.button.height) {
                legenda.isOpen = !legenda.isOpen;
                return true;
            }

            // Check section clicks if legenda is open
            if (legenda.isOpen) {
                let currentY = legenda.y + 180; // Start from bottom
                for (let i = legenda.sections.length - 1; i >= 0; i--) {
                    if (mouseX >= legenda.x && mouseX <= legenda.x + legenda.width &&
                        mouseY >= currentY - 15 && mouseY <= currentY + 5) {
                        legenda.sections[i].isOpen = !legenda.sections[i].isOpen;
                        return true;
                    }
                    currentY -= 30;
                }
            }
            return false;
        }

        function checkClickRadius(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check minigame first (including pause button)
            if (isMinigameActive) {
                if (checkMinigameClick(mouseX, mouseY)) {
                    return;
                }
            }

            // Update legenda button hover state
            legenda.button.isHovered = mouseX >= legenda.button.x && mouseX <= legenda.button.x + legenda.button.width &&
                                     mouseY >= legenda.button.y && mouseY <= legenda.button.y + legenda.button.height;

            // Check legenda clicks first
            if (checkLegendaClick(mouseX, mouseY)) {
                return;
            }

            // Check if click is in navigation bar
            if (mouseY <= navBar.height) {
                checkNavBarClick(mouseX, mouseY);
                return;
            }

            // Calculate distance from the center of the button
            const distanceToClickButton = Math.sqrt(Math.pow(mouseX - clickButton.x, 2) + Math.pow(mouseY - clickButton.y, 2));

            // Update hover state
            clickButton.isHovered = distanceToClickButton < clickButton.radius;

            // Check if the mouse click is within the button radius
            if (distanceToClickButton < clickButton.radius) {
                addPoints();
            }

            // Check upgrades from top to bottom and only buy the first one that's clicked
            let currentY = navBar.height + 5; // Start position for upgrades
            for (let upg of upgrades) {
                if (!upg.bought) {
                    // Filter upgrades based on active section
                    const shouldShow = navBar.activeSection === "all" || 
                                     (navBar.activeSection === "ppc" && upg.type === "PPC") ||
                                     (navBar.activeSection === "pps" && upg.type === "PPS");
                    
                    if (shouldShow) {
                        // Calculate the visible y position of the upgrade
                        const visibleY = currentY - scrollY;
                        
                        // Only check upgrades that are within the visible area
                        if (visibleY >= navBar.height && visibleY <= canvas.height) {
                            // Check if mouse click is within the upgrade bounds
                            if (mouseX >= upg.position.x && 
                                mouseX <= upg.position.x + upg.width &&
                                mouseY >= visibleY && 
                                mouseY <= visibleY + upg.height && 
                                score >= upg.cost) {
                                buyUpgrade(upg);
                                break;
                            }
                        }
                        currentY += upg.height + 10;
                    }
                }
            }
        }

        function shiftUpgradesUp(startIndex) {
            const spacing = upgrades[0].height + 10; // Space between upgrades
            for (let i = startIndex; i < upgrades.length; i++) {
                upgrades[i].position.y -= spacing;
            }
        }

        function buyUpgrade(upg) {
            if (score >= upg.cost) {
                const index = upgrades.indexOf(upg);
                upg.bought = true;
                score -= upg.cost;
                upg.effect();
                
                // Shift all upgrades below this one up
                shiftUpgradesUp(index + 1);
                
                // Adjust scroll position and max scroll
                const maxScroll = getMaxScroll();
                scrollY = Math.max(0, Math.min(maxScroll, scrollY));
            }
        }

        function drawBackground() {
            // Create gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');  // Dark blue at top
            gradient.addColorStop(1, '#16213e');  // Slightly lighter blue at bottom
            
            // Fill with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add subtle grid pattern
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            // Draw vertical lines
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Add subtle glow effect
            const glowGradient = ctx.createRadialGradient(
                clickButton.x, clickButton.y, 0,
                clickButton.x, clickButton.y, clickButton.radius * 2
            );
            glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
            glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = glowGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            addPPS();
            drawButton();
            drawUpgrades();
            drawMinigame();
            drawLegenda();

            requestAnimationFrame(draw);
        }

        function main() {
            addEventListeners();
            draw();
        }
        main();

    </script>
</body>
</html>